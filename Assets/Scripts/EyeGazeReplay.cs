using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;

/// <summary>
/// EyeGazeReplay — smooth Catmull‑Rom playback of a CSV log produced by EyeGazeLogger.
/// Drives a GazeLineRenderer, optional target marker, timeline UI & phoria readout.
/// </summary>
public class EyeGazeReplay : MonoBehaviour
{
    [Header("CSV & Prefabs")]
    [Tooltip("Full path to the .csv generated by EyeGazeLogger")] public string csvPath;
    [Tooltip("Prefab with a configured GazeLineRenderer")]
    public GazeLineRenderer lineRendererPrefab;
    public GameObject targetMarkerPrefab;

    [Header("UI (optional)")]
    public Slider scrubber;   // 0‑1 timeline
    public TMP_Text timeLabel;
    public TMP_Text misalignmentLabel;
    public Button playPauseButton;

    [Tooltip("Playback speed multiplier")] public float speed = 1f;

    // ───────── internal ─────────
    private struct Frame
    {
        public float t;
        public Vector3 lPos, lDir, rPos, rDir;
        public Vector3 clPos, clDir, crPos, crDir;
        public Vector3 target;   // keep if you logged it, else ignore
    }

    private readonly List<Frame> frames = new();
    private float logDuration;

    private GazeLineRenderer live;
    private Transform targetMarker;

    private bool playing = true;
    private float simClock;

    void Start()
    {
        if (!File.Exists(csvPath)) { Debug.LogError("CSV not found: " + csvPath); enabled = false; return; }
        ParseBin(csvPath);

        live = Instantiate(lineRendererPrefab);
        live.leftEyeGaze = live.rightEyeGaze = null; // disable real eye refs

        if (targetMarkerPrefab) targetMarker = Instantiate(targetMarkerPrefab).transform;

        if (scrubber)
            scrubber.onValueChanged.AddListener(v => { simClock = v * logDuration; RenderFrame(); });
        if (playPauseButton)
            playPauseButton.onClick.AddListener(() => playing = !playing);
    }

    void Update()
    {
        if (frames.Count < 2) return;
        if (playing) simClock += Time.deltaTime * speed;
        simClock = Mathf.Repeat(simClock, logDuration);

        if (scrubber) scrubber.value = simClock / logDuration;
        if (timeLabel) timeLabel.text = $"{simClock:F2} s";

        RenderFrame();
    }

    // ───────── render current clock position ─────────
    private void RenderFrame()
    {
        if (frames.Count < 2) return;

        /* 1 ─ Locate Catmull-Rom control points around simClock */
        int i1 = frames.FindIndex(f => f.t > simClock);
        if (i1 < 1) i1 = 1;
        if (i1 >= frames.Count) i1 = frames.Count - 1;
        int i0 = i1 - 1;
        int iM = Mathf.Max(0, i0 - 1);
        int iP = Mathf.Min(frames.Count - 1, i1 + 1);

        Frame p0 = frames[iM];
        Frame p1 = frames[i0];
        Frame p2 = frames[i1];
        Frame p3 = frames[iP];

        float u = Mathf.InverseLerp(p1.t, p2.t, simClock);

        /* 2 ─ Interpolate RAW data */
        Vector3 lPos = Catmull(p0.lPos, p1.lPos, p2.lPos, p3.lPos, u);
        Vector3 rPos = Catmull(p0.rPos, p1.rPos, p2.rPos, p3.rPos, u);
        Vector3 lDir = SlerpDir(p1.lDir, p2.lDir, u);
        Vector3 rDir = SlerpDir(p1.rDir, p2.rDir, u);

        /* 3 ─ Interpolate CALIBRATED data */
        Vector3 clPos = Catmull(p0.clPos, p1.clPos, p2.clPos, p3.clPos, u);
        Vector3 crPos = Catmull(p0.crPos, p1.crPos, p2.crPos, p3.crPos, u);
        Vector3 clDir = SlerpDir(p1.clDir, p2.clDir, u);
        Vector3 crDir = SlerpDir(p1.crDir, p2.crDir, u);

        /* 4 ─ Optional target (0-vector if not logged) */
        Vector3 tgt = Catmull(p0.target, p1.target, p2.target, p3.target, u);
        if (targetMarker) targetMarker.position = tgt;

        /* 5 ─ Draw lines */
        live.VisualizeExternal(lPos, lDir, rPos, rDir);          // raw (green/red)
        live.VisualizeExternalCalibrated(clPos, clDir, crPos, crDir); // calibrated (blue/gray)

        /* 6 ─ Misalignment metrics */
        var res = EyeMisalignmentCalculator.CalculateEyeMisalignment(
            clPos, clDir, crPos, crDir, tgt, out _);

        if (misalignmentLabel)
            misalignmentLabel.text = res == null
                ? "--"
                : $"Φ L/R {res.LeftPhoria:F2}/{res.RightPhoria:F2}  Τ L/R {res.LeftTropia:F2}/{res.RightTropia:F2}";
    }


    // ───────── interpolation helpers ─────────
    private static Vector3 Catmull(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float t)
    {
        return 0.5f * ((2 * b) + (-a + c) * t + t * t * (2 * a - 5 * b + 4 * c - d) + t * t * t * (-a + 3 * b - 3 * c + d));
    }


    private static Vector3 SlerpDir(Vector3 a, Vector3 b, float t)
    {
        if (a != Vector3.zero && b != Vector3.zero) return (Quaternion.Slerp(Quaternion.LookRotation(a),
                                 Quaternion.LookRotation(b), t)
                * Vector3.forward).normalized;

        return Vector3.zero;
    }

    // ------------ binary loader with calibrated rays ------------
    private void ParseBin(string path)
    {
        const int BLOCK = 100;          // 31 floats × 4  (112 if target not recorded)
        using FileStream fs = File.OpenRead(path);

        byte[] header = new byte[8];
        if (fs.Read(header, 0, 8) != 8 || System.Text.Encoding.ASCII.GetString(header, 0, 4) != "GZB1")
        { Debug.LogError("Bad header"); enabled = false; return; }

        var inv = System.Globalization.CultureInfo.InvariantCulture;
        byte[] buf = new byte[BLOCK];

        while (fs.Read(buf, 0, BLOCK) == BLOCK)
        {
            int o = 0;
            float t = ReadF();

            Vector3 lPos = Rv(); Vector3 lDir = Rv();
            Vector3 rPos = Rv(); Vector3 rDir = Rv();
            Vector3 clPos = Rv(); Vector3 clDir = Rv();
            Vector3 crPos = Rv(); Vector3 crDir = Rv();

            frames.Add(new Frame
            {
                t = t,
                lPos = lPos,
                lDir = lDir,
                rPos = rPos,
                rDir = rDir,
                clPos = clPos,
                clDir = clDir,
                crPos = crPos,
                crDir = crDir
            });

            // local readers -----
            float ReadF() { float f = BitConverter.ToSingle(buf, o); o += 4; return f; }
            Vector3 Rv() { return new Vector3(ReadF(), ReadF(), ReadF()); }
        }
        logDuration = frames[^1].t;


    }


}
